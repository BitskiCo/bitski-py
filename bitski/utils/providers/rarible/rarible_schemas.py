# generated by datamodel-codegen:
#   filename:  openapi.yaml
#   timestamp: 2021-08-16T06:59:34+00:00

from __future__ import annotations

from datetime import datetime
from enum import Enum
from typing import Dict, List, Optional, Union

from pydantic import BaseModel, Field


class Code(Enum):
    UNKNOWN = "UNKNOWN"
    VALIDATION = "VALIDATION"


class GatewayApiError(BaseModel):
    status: int
    code: Code
    message: str


class Code1(Enum):
    UNKNOWN = "UNKNOWN"
    VALIDATION = "VALIDATION"
    TOKEN_NOT_FOUND = "TOKEN_NOT_FOUND"
    BALANCE_NOT_FOUND = "BALANCE_NOT_FOUND"


class Erc20IndexerApiError(BaseModel):
    status: int
    code: Code1
    message: str


class Erc20BalanceEvent(BaseModel):
    eventId: str
    balanceId: str


class Type(Enum):
    UPDATE = "UPDATE"


class Address(BaseModel):
    __root__: str = Field(..., example="0x60f80121c31a0d46b5279700f9df786054aa5ee5")


class BigInteger(BaseModel):
    __root__: str = Field(..., example=717802)


class BigDecimal(BaseModel):
    __root__: str = Field(..., example=717802.342336)


class Type1(Enum):
    ERC721 = "ERC721"
    ERC1155 = "ERC1155"


class Feature(Enum):
    APPROVE_FOR_ALL = "APPROVE_FOR_ALL"
    SET_URI_PREFIX = "SET_URI_PREFIX"
    BURN = "BURN"
    MINT_WITH_ADDRESS = "MINT_WITH_ADDRESS"
    SECONDARY_SALE_FEES = "SECONDARY_SALE_FEES"
    MINT_AND_TRANSFER = "MINT_AND_TRANSFER"


class NftCollection(BaseModel):
    id: Address
    type: Type1
    owner: Optional[Address] = None
    name: str
    symbol: Optional[str] = None
    features: List[Feature]


class NftCollections(BaseModel):
    total: int = Field(..., description="Number of collections were found by request")
    continuation: Optional[str] = Field(
        None, description="Continuation token to paginate items search result"
    )
    collections: List[NftCollection] = Field(
        ..., description="List of found collections"
    )


class NftCollectionHistory(BaseModel):
    id: Address


class Type2(Enum):
    COLLECTION_CREATE = "COLLECTION_CREATE"


class NftCreateCollection(BaseModel):
    type: Optional[Type2] = None
    owner: Address
    name: str
    symbol: str


class Code2(Enum):
    UNKNOWN = "UNKNOWN"
    BAD_REQUEST = "BAD_REQUEST"
    VALIDATION = "VALIDATION"
    ITEM_NOT_FOUND = "ITEM_NOT_FOUND"
    LAZY_ITEM_NOT_FOUND = "LAZY_ITEM_NOT_FOUND"
    TOKEN_NOT_FOUND = "TOKEN_NOT_FOUND"
    TOKEN_URI_NOT_FOUND = "TOKEN_URI_NOT_FOUND"
    TOKEN_PROPERTIES_EXTRACT = "TOKEN_PROPERTIES_EXTRACT"
    OWNERSHIP_NOT_FOUND = "OWNERSHIP_NOT_FOUND"
    COLLECTION_NOT_FOUND = "COLLECTION_NOT_FOUND"
    INCORRECT_LAZY_NFT = "INCORRECT_LAZY_NFT"


class NftIndexerApiError(BaseModel):
    status: int
    code: Code2
    message: str


class Sort(Enum):
    LAST_UPDATE = "LAST_UPDATE"


class NftItemFilter(BaseModel):
    sort: Sort


class _Type(Enum):
    all = "all"


class NftItemFilterAll(BaseModel):
    _type: _Type = Field(..., alias="@type")
    showDeleted: bool
    lastUpdatedFrom: Optional[datetime] = None


class _Type1(Enum):
    by_owner = "by_owner"


class NftItemFilterByOwner(BaseModel):
    _type: _Type1 = Field(..., alias="@type")
    owner: Address


class _Type2(Enum):
    by_creator = "by_creator"


class NftItemFilterByCreator(BaseModel):
    _type: _Type2 = Field(..., alias="@type")
    creator: Address


class _Type3(Enum):
    by_collection = "by_collection"


class NftItemFilterByCollection(BaseModel):
    _type: _Type3 = Field(..., alias="@type")
    collection: Address


class Sort1(Enum):
    LAST_UPDATE = "LAST_UPDATE"


class NftOwnershipFilter(BaseModel):
    sort: Sort1


class _Type4(Enum):
    all = "all"


class NftOwnershipFilterAll(BaseModel):
    _type: _Type4 = Field(..., alias="@type")


class _Type5(Enum):
    by_owner = "by_owner"


class NftOwnershipFilterByOwner(BaseModel):
    _type: _Type5 = Field(..., alias="@type")
    owner: Address


class _Type6(Enum):
    by_creator = "by_creator"


class NftOwnershipFilterByCreator(BaseModel):
    _type: _Type6 = Field(..., alias="@type")
    creator: Address


class _Type7(Enum):
    by_collection = "by_collection"


class NftOwnershipFilterByCollection(BaseModel):
    _type: _Type7 = Field(..., alias="@type")
    collection: Address


class _Type8(Enum):
    by_item = "by_item"


class NftOwnershipFilterByItem(BaseModel):
    _type: _Type8 = Field(..., alias="@type")
    contract: Address
    tokenId: BigInteger


class Direction(Enum):
    ASC = "ASC"
    DESC = "DESC"


class NftSort(BaseModel):
    property: str
    direction: Direction


class NftItemAttribute(BaseModel):
    key: str
    value: Optional[str] = None


class NftDeletedItem(BaseModel):
    id: str = Field(..., description='Item identifier, has format "contract:tokenId"')
    token: Address
    tokenId: BigInteger


class NftItemEvent(BaseModel):
    eventId: str
    itemId: str


class Type3(Enum):
    UPDATE = "UPDATE"


class Type4(Enum):
    DELETE = "DELETE"


class NftItemDeleteEvent(BaseModel):
    type: Optional[Type4] = None
    item: NftDeletedItem


class NftMediaMeta(BaseModel):
    type: str
    width: Optional[int] = None
    height: Optional[int] = None


class _Type9(Enum):
    ERC1155 = "ERC1155"


class LazyErc1155(BaseModel):
    _type: _Type9 = Field(..., alias="@type")
    supply: BigInteger


class _Type10(Enum):
    ERC721 = "ERC721"


class LazyErc721(BaseModel):
    _type: _Type10 = Field(..., alias="@type")


class NftDeletedOwnership(BaseModel):
    id: str = Field(
        ..., description='Ownership identifier, has format "token:tokenId:owner"'
    )
    token: Address
    tokenId: BigInteger
    owner: Address


class NftOwnershipEvent(BaseModel):
    eventId: str
    ownershipId: str


class Type5(Enum):
    UPDATE = "UPDATE"


class Type6(Enum):
    DELETE = "DELETE"


class NftOwnershipDeleteEvent(BaseModel):
    type: Optional[Type6] = None
    ownership: NftDeletedOwnership


class NftMediaSize(Enum):
    ORIGINAL = "ORIGINAL"
    BIG = "BIG"
    PREVIEW = "PREVIEW"


class Activity(BaseModel):
    id: str
    date: datetime


class Type7(Enum):
    SELL = "SELL"
    BID = "BID"


class Source(Enum):
    RARIBLE = "RARIBLE"
    OPEN_SEA = "OPEN_SEA"


class OrderActivity1(BaseModel):
    id: str
    date: datetime
    source: Source


class _Type11(Enum):
    match = "match"


class _Type12(Enum):
    bid = "bid"


class _Type13(Enum):
    list = "list"


class _Type14(Enum):
    cancel_bid = "cancel_bid"


class _Type15(Enum):
    cancel_list = "cancel_list"


class _Type16(Enum):
    mint = "mint"


class Mint(BaseModel):
    _type: Optional[_Type16] = Field(None, alias="@type")


class _Type17(Enum):
    burn = "burn"


class Burn(BaseModel):
    _type: _Type17 = Field(..., alias="@type")


class _Type18(Enum):
    transfer = "transfer"


class Transfer(BaseModel):
    _type: _Type18 = Field(..., alias="@type")
    from_: Address = Field(..., alias="from")


class ActivityContinuation(BaseModel):
    afterDate: datetime
    afterId: str


class _Type19(Enum):
    all = "all"


class Type8(Enum):
    TRANSFER = "TRANSFER"
    MINT = "MINT"
    BURN = "BURN"
    BID = "BID"
    LIST = "LIST"
    SELL = "SELL"


class ActivityFilterAll(BaseModel):
    _type: _Type19 = Field(..., alias="@type")
    types: List[Type8]


class _Type20(Enum):
    by_user = "by_user"


class Type9(Enum):
    TRANSFER_FROM = "TRANSFER_FROM"
    TRANSFER_TO = "TRANSFER_TO"
    MINT = "MINT"
    BURN = "BURN"
    MAKE_BID = "MAKE_BID"
    GET_BID = "GET_BID"
    LIST = "LIST"
    BUY = "BUY"
    SELL = "SELL"


class ActivityFilterByUser(BaseModel):
    _type: _Type20 = Field(..., alias="@type")
    users: List[Address]
    types: List[Type9]


class _Type21(Enum):
    by_item = "by_item"


class Type10(Enum):
    TRANSFER = "TRANSFER"
    MINT = "MINT"
    BURN = "BURN"
    BID = "BID"
    LIST = "LIST"
    MATCH = "MATCH"


class ActivityFilterByItem(BaseModel):
    _type: _Type21 = Field(..., alias="@type")
    contract: Address
    tokenId: BigInteger
    types: List[Type10]


class _Type22(Enum):
    by_collection = "by_collection"


class Type11(Enum):
    TRANSFER = "TRANSFER"
    MINT = "MINT"
    BURN = "BURN"
    BID = "BID"
    LIST = "LIST"
    MATCH = "MATCH"


class ActivityFilterByCollection(BaseModel):
    _type: _Type22 = Field(..., alias="@type")
    contract: Address
    types: List[Type11]


class _Type23(Enum):
    all = "all"


class Type12(Enum):
    TRANSFER = "TRANSFER"
    MINT = "MINT"
    BURN = "BURN"


class NftActivityFilterAll(BaseModel):
    _type: _Type23 = Field(..., alias="@type")
    types: List[Type12]


class _Type24(Enum):
    by_user = "by_user"


class Type13(Enum):
    TRANSFER_FROM = "TRANSFER_FROM"
    TRANSFER_TO = "TRANSFER_TO"
    MINT = "MINT"
    BURN = "BURN"


class NftActivityFilterByUser(BaseModel):
    _type: _Type24 = Field(..., alias="@type")
    users: List[Address]
    types: List[Type13]


class _Type25(Enum):
    by_item = "by_item"


class Type14(Enum):
    TRANSFER = "TRANSFER"
    MINT = "MINT"
    BURN = "BURN"


class NftActivityFilterByItem(BaseModel):
    _type: _Type25 = Field(..., alias="@type")
    contract: Address
    tokenId: BigInteger
    types: List[Type14]


class _Type26(Enum):
    by_collection = "by_collection"


class Type15(Enum):
    TRANSFER = "TRANSFER"
    MINT = "MINT"
    BURN = "BURN"


class NftActivityFilterByCollection(BaseModel):
    _type: _Type26 = Field(..., alias="@type")
    contract: Address
    types: List[Type15]


class _Type27(Enum):
    all = "all"


class Type16(Enum):
    BID = "BID"
    LIST = "LIST"
    MATCH = "MATCH"


class OrderActivityFilterAll(BaseModel):
    _type: _Type27 = Field(..., alias="@type")
    types: List[Type16]


class _Type28(Enum):
    by_user = "by_user"


class Type17(Enum):
    MAKE_BID = "MAKE_BID"
    GET_BID = "GET_BID"
    LIST = "LIST"
    BUY = "BUY"
    SELL = "SELL"


class OrderActivityFilterByUser(BaseModel):
    _type: _Type28 = Field(..., alias="@type")
    users: List[Address]
    types: List[Type17]


class _Type29(Enum):
    by_item = "by_item"


class Type18(Enum):
    BID = "BID"
    LIST = "LIST"
    MATCH = "MATCH"


class OrderActivityFilterByItem(BaseModel):
    _type: _Type29 = Field(..., alias="@type")
    contract: Address
    tokenId: BigInteger
    types: List[Type18]


class _Type30(Enum):
    by_collection = "by_collection"


class Type19(Enum):
    BID = "BID"
    LIST = "LIST"
    MATCH = "MATCH"


class OrderActivityFilterByCollection(BaseModel):
    _type: _Type30 = Field(..., alias="@type")
    contract: Address
    types: List[Type19]


class ItemHistory1(BaseModel):
    owner: Optional[Address] = None
    contract: Address
    tokenId: BigInteger
    value: Optional[BigInteger] = None
    date: datetime


class Type20(Enum):
    ROYALTY = "ROYALTY"


class Type21(Enum):
    TRANSFER = "TRANSFER"


class ItemTransfer(BaseModel):
    type: Type21
    from_: Address = Field(..., alias="from")


class AssetClass(Enum):
    ETH = "ETH"


class EthAssetType(BaseModel):
    assetClass: AssetClass


class AssetClass1(Enum):
    FLOW = "FLOW"


class FlowAssetType(BaseModel):
    assetClass: AssetClass1


class AssetClass2(Enum):
    ERC20 = "ERC20"


class Erc20AssetType(BaseModel):
    assetClass: AssetClass2
    contract: Address


class AssetClass3(Enum):
    ERC721 = "ERC721"


class Erc721AssetType(BaseModel):
    assetClass: AssetClass3
    contract: Address
    tokenId: BigInteger


class AssetClass4(Enum):
    ERC1155 = "ERC1155"


class Erc1155AssetType(BaseModel):
    assetClass: AssetClass4
    contract: Address
    tokenId: BigInteger


class AssetClass5(Enum):
    ERC721_LAZY = "ERC721_LAZY"


class AssetClass6(Enum):
    ERC1155_LAZY = "ERC1155_LAZY"


class Part(BaseModel):
    account: Address
    value: int


class Status(Enum):
    PENDING = "PENDING"
    CONFIRMED = "CONFIRMED"
    REVERTED = "REVERTED"
    DROPPED = "DROPPED"
    INACTIVE = "INACTIVE"


class Word(BaseModel):
    __root__: str


class Binary(BaseModel):
    __root__: str


class Code3(Enum):
    UNKNOWN = "UNKNOWN"
    SERVER_ERROR = "SERVER_ERROR"
    ABSENCE_OF_REQUIRED_FIELD = "ABSENCE_OF_REQUIRED_FIELD"
    INVALID_ARGUMENT = "INVALID_ARGUMENT"
    ORDER_NOT_FOUND = "ORDER_NOT_FOUND"
    BALANCE_NOT_FOUND = "BALANCE_NOT_FOUND"
    OWNERSHIP_NOT_FOUND = "OWNERSHIP_NOT_FOUND"
    LAZY_ITEM_NOT_FOUND = "LAZY_ITEM_NOT_FOUND"
    INCORRECT_SIGNATURE = "INCORRECT_SIGNATURE"
    INCORRECT_ORDER_DATA = "INCORRECT_ORDER_DATA"
    INCORRECT_LAZY_ASSET = "INCORRECT_LAZY_ASSET"
    ORDER_CANCELED = "ORDER_CANCELED"
    ORDER_INVALID_UPDATE = "ORDER_INVALID_UPDATE"
    ASSET_BALANCE_NOT_FOUND = "ASSET_BALANCE_NOT_FOUND"


class OrderIndexerApiError(BaseModel):
    status: int
    code: Code3
    message: str


class AggregationData(BaseModel):
    address: Address
    sum: BigDecimal
    count: int


class Type22(Enum):
    RARIBLE_V1 = "RARIBLE_V1"


class Type23(Enum):
    RARIBLE_V2 = "RARIBLE_V2"


class Type24(Enum):
    OPEN_SEA_V1 = "OPEN_SEA_V1"


class OrderBidStatus(Enum):
    ACTIVE = "ACTIVE"
    FILLED = "FILLED"
    HISTORICAL = "HISTORICAL"
    INACTIVE = "INACTIVE"
    CANCELLED = "CANCELLED"


class EncodedOrderData(BaseModel):
    type: Binary
    data: Binary


class _Type31(Enum):
    EIP712 = "EIP712"


class EIP712Domain(BaseModel):
    name: str
    version: str
    chainId: int
    verifyingContract: Address


class _Type32(Enum):
    TEXT = "TEXT"


class TextSignMessage(BaseModel):
    _type: _Type32 = Field(..., alias="@type")
    message: str


class Type25(Enum):
    BUY = "BUY"


class ItemBuy(BaseModel):
    type: Optional[Type25] = None
    fill: BigInteger
    buyer: Optional[Address] = None


class OrderSide(Enum):
    LEFT = "LEFT"
    RIGHT = "RIGHT"


class Type26(Enum):
    ORDER_SIDE_MATCH = "ORDER_SIDE_MATCH"


class OrderSideMatch(BaseModel):
    type: Type26
    side: Optional[OrderSide] = None
    fill: BigInteger
    taker: Optional[Address] = None
    counterHash: Optional[Word] = None
    makeUsd: Optional[BigDecimal] = None
    takeUsd: Optional[BigDecimal] = None
    makePriceUsd: Optional[BigDecimal] = None
    takePriceUsd: Optional[BigDecimal] = None


class Type27(Enum):
    CANCEL = "CANCEL"


class OrderCancel(BaseModel):
    type: Type27
    owner: Optional[Address] = None


class DataType(Enum):
    RARIBLE_V2_DATA_V1 = "RARIBLE_V2_DATA_V1"


class OrderRaribleV2DataV1(BaseModel):
    dataType: DataType
    payouts: List[Part]
    originFees: List[Part]


class DataType1(Enum):
    LEGACY = "LEGACY"


class OrderDataLegacy(BaseModel):
    dataType: DataType1
    fee: int


class DataType2(Enum):
    OPEN_SEA_V1_DATA_V1 = "OPEN_SEA_V1_DATA_V1"


class FeeMethod(Enum):
    PROTOCOL_FEE = "PROTOCOL_FEE"
    SPLIT_FEE = "SPLIT_FEE"


class Side(Enum):
    BUY = "BUY"
    SELL = "SELL"


class SaleKind(Enum):
    FIXED_PRICE = "FIXED_PRICE"
    DUTCH_AUCTION = "DUTCH_AUCTION"


class HowToCall(Enum):
    CALL = "CALL"
    DELEGATE_CALL = "DELEGATE_CALL"


class OrderOpenSeaV1DataV1(BaseModel):
    dataType: DataType2
    exchange: Address
    makerRelayerFee: BigInteger
    takerRelayerFee: BigInteger
    makerProtocolFee: BigInteger
    takerProtocolFee: BigInteger
    feeRecipient: Address
    feeMethod: FeeMethod
    side: Side
    saleKind: SaleKind
    howToCall: HowToCall
    callData: Binary
    replacementPattern: Binary
    staticTarget: Address
    staticExtraData: Binary
    extra: BigInteger


class Type28(Enum):
    RARIBLE_V1 = "RARIBLE_V1"


class LegacyOrder(BaseModel):
    type: Type28
    data: OrderDataLegacy


class Type29(Enum):
    RARIBLE_V2 = "RARIBLE_V2"


class RaribleV2Order(BaseModel):
    type: Type29
    data: OrderRaribleV2DataV1


class Type30(Enum):
    OPEN_SEA_V1 = "OPEN_SEA_V1"


class OpenSeaV1Order(BaseModel):
    type: Type30
    data: OrderOpenSeaV1DataV1


class Type31(Enum):
    RARIBLE_V1 = "RARIBLE_V1"


class LegacyOrderForm(BaseModel):
    type: Type31
    data: OrderDataLegacy


class Type32(Enum):
    RARIBLE_V2 = "RARIBLE_V2"


class RaribleV2OrderForm(BaseModel):
    type: Type32
    data: OrderRaribleV2DataV1


class Type33(Enum):
    OPEN_SEA_V1 = "OPEN_SEA_V1"


class OpenSeaV1OrderForm(BaseModel):
    type: Type33
    data: OrderOpenSeaV1DataV1


class Platform(Enum):
    ALL = "ALL"
    RARIBLE = "RARIBLE"
    OPEN_SEA = "OPEN_SEA"


class InvertOrderForm(BaseModel):
    maker: Address
    amount: BigInteger
    salt: Word
    originFees: List[Part]


class OrderEvent(BaseModel):
    eventId: str
    orderId: str


class Type34(Enum):
    UPDATE = "UPDATE"


class Sort2(Enum):
    LAST_UPDATE = "LAST_UPDATE"
    TAKE_PRICE_DESC = "TAKE_PRICE_DESC"
    MAKE_PRICE_ASC = "MAKE_PRICE_ASC"


class OrderFilter(BaseModel):
    origin: Optional[Address] = None
    platform: Optional[Platform] = None
    sort: Sort2


class _Type33(Enum):
    all = "all"


class OrderFilterAll(BaseModel):
    _type: _Type33 = Field(..., alias="@type")


class _Type34(Enum):
    sell = "sell"


class OrderFilterSell(BaseModel):
    _type: _Type34 = Field(..., alias="@type")


class _Type35(Enum):
    sell_by_item = "sell_by_item"


class OrderFilterSellByItem(BaseModel):
    _type: _Type35 = Field(..., alias="@type")
    contract: Address
    tokenId: BigInteger
    maker: Optional[Address] = None


class _Type36(Enum):
    sell_by_collection = "sell_by_collection"


class OrderFilterSellByCollection(BaseModel):
    _type: _Type36 = Field(..., alias="@type")
    collection: Address


class _Type37(Enum):
    sell_by_maker = "sell_by_maker"


class OrderFilterSellByMaker(BaseModel):
    _type: _Type37 = Field(..., alias="@type")
    maker: Address


class _Type38(Enum):
    bid_by_item = "bid_by_item"


class OrderFilterBidByItem(BaseModel):
    _type: _Type38 = Field(..., alias="@type")
    contract: Address
    tokenId: BigInteger
    maker: Optional[Address] = None


class _Type39(Enum):
    bid_by_maker = "bid_by_maker"


class OrderFilterBidByMaker(BaseModel):
    _type: _Type39 = Field(..., alias="@type")
    maker: Address


class PrepareOrderTxForm(BaseModel):
    maker: Address
    amount: BigInteger
    payouts: List[Part]
    originFees: List[Part]


class PreparedOrderTx(BaseModel):
    to: Address
    data: Binary


class ObjectNode(BaseModel):
    pass


class Lock(BaseModel):
    id: str
    itemId: str
    content: str
    author: Address
    signature: Optional[Binary] = None
    unlockDate: Optional[datetime] = None
    version: Optional[int] = None


class LockForm(BaseModel):
    signature: Optional[Binary] = None
    content: str


class SignatureForm(BaseModel):
    signature: Optional[Binary] = None


class Code4(Enum):
    UNKNOWN = "UNKNOWN"
    LOCK_EXISTS = "LOCK_EXISTS"
    OWNERHIP_ERROR = "OWNERHIP_ERROR"


class UnlockableApiError(BaseModel):
    status: int
    code: Code4
    message: str


class Type35(Enum):
    LOCK_CREATED = "LOCK_CREATED"
    LOCK_UNLOCKED = "LOCK_UNLOCKED"


class UnlockableEvent(BaseModel):
    eventId: str
    itemId: str
    type: Type35


class Erc20Balance(BaseModel):
    contract: Address
    owner: Address
    balance: BigInteger


class Erc20DecimalBalance(BaseModel):
    contract: Address
    owner: Address
    balance: BigInteger
    decimalBalance: BigDecimal


class Erc20Token(BaseModel):
    id: Address
    name: Optional[str] = None
    symbol: Optional[str] = None


class Erc20BalanceUpdateEvent(BaseModel):
    type: Optional[Type] = None
    balance: Erc20Balance


class NftCollectionHistory1(BaseModel):
    __root__: Union[NftCollectionHistory, NftCreateCollection]


class NftSignature(BaseModel):
    v: str
    r: Binary
    s: Binary


class NftTokenId(BaseModel):
    tokenId: BigInteger
    signature: NftSignature


class NftItemFilter1(BaseModel):
    __root__: Union[
        NftItemFilter,
        NftItemFilterAll,
        NftItemFilterByOwner,
        NftItemFilterByCreator,
        NftItemFilterByCollection,
    ]


class NftOwnershipFilter1(BaseModel):
    __root__: Union[
        NftOwnershipFilter,
        NftOwnershipFilterAll,
        NftOwnershipFilterByOwner,
        NftOwnershipFilterByCreator,
        NftOwnershipFilterByCollection,
        NftOwnershipFilterByItem,
    ]


class NftMedia(BaseModel):
    url: Dict[str, str]
    meta: Dict[str, NftMediaMeta]


class LazyNft(BaseModel):
    contract: Address
    tokenId: BigInteger
    uri: str
    creators: List[Part]
    royalties: List[Part]
    signatures: List[Binary]


class LazyNft1(BaseModel):
    __root__: Union[LazyNft, LazyErc721, LazyErc1155] = Field(
        ..., description="Type of an Asset"
    )


class NftActivity1(BaseModel):
    owner: Address
    contract: Address
    tokenId: BigInteger
    value: BigInteger
    transactionHash: Word
    blockHash: Word
    blockNumber: int
    logIndex: int


class NftActivity(BaseModel):
    __root__: Union[NftActivity1, Mint, Burn, Transfer]


class ActivityFilter(BaseModel):
    __root__: Union[
        ActivityFilterAll,
        ActivityFilterByUser,
        ActivityFilterByItem,
        ActivityFilterByCollection,
    ]


class NftActivityFilter(BaseModel):
    __root__: Union[
        NftActivityFilterAll,
        NftActivityFilterByUser,
        NftActivityFilterByItem,
        NftActivityFilterByCollection,
    ]


class OrderActivityFilter(BaseModel):
    __root__: Union[
        OrderActivityFilterAll,
        OrderActivityFilterByUser,
        OrderActivityFilterByItem,
        OrderActivityFilterByCollection,
    ]


class ItemRoyalty(BaseModel):
    type: Type20
    royalties: List[Part]


class Erc721LazyAssetType(BaseModel):
    assetClass: AssetClass5
    contract: Address
    tokenId: BigInteger
    uri: str
    creators: List[Part]
    royalties: List[Part]
    signatures: List[Binary]


class Erc1155LazyAssetType(BaseModel):
    assetClass: AssetClass6
    contract: Address
    tokenId: BigInteger
    uri: str
    supply: BigInteger
    creators: List[Part]
    royalties: List[Part]
    signatures: List[Binary]


class CreateTransactionRequest(BaseModel):
    hash: Word
    from_: Address = Field(..., alias="from")
    nonce: int
    to: Optional[Address] = None
    input: Binary


class LogEvent(BaseModel):
    transactionHash: Word
    status: Status
    address: Address
    from_: Optional[Address] = Field(None, alias="from")
    topic: Word
    nonce: Optional[int] = None


class LegacyOrderBid(BaseModel):
    type: Type22
    data: OrderDataLegacy


class RaribleV2OrderBid(BaseModel):
    type: Type23
    data: OrderRaribleV2DataV1


class OpenSeaV1OrderBid(BaseModel):
    type: Type24
    data: OrderOpenSeaV1DataV1


class EIP712SignMessage(BaseModel):
    _type: _Type31 = Field(..., alias="@type")
    domain: EIP712Domain
    struct: ObjectNode
    structType: str
    types: ObjectNode


class OrderData(BaseModel):
    __root__: Union[OrderRaribleV2DataV1, OrderDataLegacy, OrderOpenSeaV1DataV1]


class OrderFilter1(BaseModel):
    __root__: Union[
        OrderFilter,
        OrderFilterAll,
        OrderFilterSell,
        OrderFilterSellByItem,
        OrderFilterSellByCollection,
        OrderFilterSellByMaker,
        OrderFilterBidByItem,
        OrderFilterBidByMaker,
    ]


class Erc20BalanceEvent1(BaseModel):
    __root__: Union[Erc20BalanceEvent, Erc20BalanceUpdateEvent]


class NftActivities(BaseModel):
    continuation: Optional[str] = Field(
        None, description="Continuation token to paginate items search result"
    )
    items: List[NftActivity] = Field(..., description="List of found activities")


class NftItemMeta(BaseModel):
    name: str
    description: Optional[str] = None
    attributes: Optional[List[NftItemAttribute]] = None
    image: Optional[NftMedia] = None
    animation: Optional[NftMedia] = None


class ItemHistory(BaseModel):
    __root__: Union[ItemHistory1, ItemRoyalty, ItemTransfer] = Field(
        ..., description="History of item"
    )


class AssetType(BaseModel):
    __root__: Union[
        EthAssetType,
        FlowAssetType,
        Erc20AssetType,
        Erc721AssetType,
        Erc1155AssetType,
        Erc721LazyAssetType,
        Erc1155LazyAssetType,
    ]


class Asset(BaseModel):
    assetType: AssetType
    value: BigInteger


class OrderBid(BaseModel):
    orderHash: Word
    status: OrderBidStatus
    maker: Address
    taker: Optional[Address] = None
    make: Asset
    take: Asset
    makeBalance: Optional[BigInteger] = None
    makePriceUsd: Optional[BigDecimal] = None
    takePriceUsd: Optional[BigDecimal] = None
    fill: BigInteger
    makeStock: BigInteger
    cancelled: bool
    salt: Binary
    signature: Optional[Binary] = None
    createdAt: datetime


class OrderBid1(BaseModel):
    __root__: Union[OrderBid, LegacyOrderBid, RaribleV2OrderBid, OpenSeaV1OrderBid]


class SignMessage(BaseModel):
    __root__: Union[EIP712SignMessage, TextSignMessage]


class EncodedOrder(BaseModel):
    transferProxyAddress: Optional[Address] = None
    signMessage: SignMessage


class OrderExchangeHistory(BaseModel):
    hash: Word
    make: Optional[Asset] = None
    take: Optional[Asset] = None
    date: datetime
    maker: Optional[Address] = None


class OrderExchangeHistory1(BaseModel):
    __root__: Union[OrderExchangeHistory, OrderCancel, OrderSideMatch]


class OrderBidsPagination(BaseModel):
    items: List[OrderBid1]
    continuation: Optional[str] = None


class Order(BaseModel):
    maker: Address
    taker: Optional[Address] = None
    make: Asset
    take: Asset
    fill: BigInteger
    start: Optional[int] = None
    end: Optional[int] = None
    makeStock: BigInteger
    cancelled: bool
    salt: Word
    signature: Optional[Binary] = None
    createdAt: datetime
    lastUpdateAt: datetime
    pending: Optional[List[OrderExchangeHistory1]] = None
    hash: Word
    makeBalance: Optional[BigInteger] = None
    makePriceUsd: Optional[BigDecimal] = None
    takePriceUsd: Optional[BigDecimal] = None


class Order1(BaseModel):
    __root__: Union[Order, LegacyOrder, RaribleV2Order, OpenSeaV1Order]


class OrderForm(BaseModel):
    maker: Address
    taker: Optional[Address] = None
    make: Asset
    take: Asset
    salt: Word
    start: Optional[int] = None
    end: Optional[int] = None
    signature: Optional[Binary] = None


class OrderForm1(BaseModel):
    __root__: Union[OrderForm, LegacyOrderForm, RaribleV2OrderForm, OpenSeaV1OrderForm]


class OrdersPagination(BaseModel):
    orders: List[Order1]
    continuation: Optional[str] = None


class OrderUpdateEvent(BaseModel):
    type: Optional[Type34] = None
    order: Order1


class PrepareOrderTxResponse(BaseModel):
    transferProxyAddress: Optional[Address] = None
    asset: Asset
    transaction: PreparedOrderTx


class NftItem(BaseModel):
    id: str = Field(..., description='Item identifier, has format "contract:tokenId"')
    contract: Address
    tokenId: BigInteger
    creators: List[Part] = Field(..., description="Creators of the target item")
    supply: BigInteger
    lazySupply: BigInteger
    owners: List[Address] = Field(..., description="Owners of the target items")
    royalties: List[Part] = Field(..., description="List of royalties")
    date: Optional[datetime] = None
    pending: Optional[List[ItemTransfer]] = None
    deleted: Optional[bool] = None
    meta: Optional[NftItemMeta] = None


class NftItemUpdateEvent(BaseModel):
    type: Optional[Type3] = None
    item: NftItem


class NftItems(BaseModel):
    total: int = Field(..., description="Number of items were found by request")
    continuation: Optional[str] = Field(
        None, description="Continuation token to paginate items search result"
    )
    items: List[NftItem] = Field(..., description="List of found items")


class NftOwnership(BaseModel):
    id: str = Field(
        ..., description='Ownership identifier, has format "token:tokenId:owner"'
    )
    contract: Address
    tokenId: BigInteger
    owner: Address
    creators: List[Part] = Field(..., description="Creators of the target item")
    value: BigInteger
    lazyValue: BigInteger
    date: datetime = Field(..., description="Start date of ownership")
    pending: List[ItemHistory] = Field(..., description="History of ownership")


class NftOwnershipUpdateEvent(BaseModel):
    type: Optional[Type5] = None
    ownership: NftOwnership


class NftOwnerships(BaseModel):
    total: int = Field(..., description="Number of ownerships were found by request")
    continuation: Optional[str] = Field(
        None, description="Continuation token to paginate Ownerships search result"
    )
    ownerships: List[NftOwnership] = Field(..., description="List of found ownerships")


class OrderActivityMatchSide(BaseModel):
    maker: Address
    hash: Word
    asset: Asset
    type: Optional[Type7] = None


class OrderActivityMatch(BaseModel):
    _type: _Type11 = Field(..., alias="@type")
    left: OrderActivityMatchSide
    right: OrderActivityMatchSide
    price: BigDecimal
    priceUsd: Optional[BigDecimal] = None
    transactionHash: Word
    blockHash: Word
    blockNumber: int
    logIndex: int


class OrderActivityBid(BaseModel):
    _type: _Type12 = Field(..., alias="@type")
    hash: Word
    maker: Address
    make: Asset
    take: Asset
    price: BigDecimal
    priceUsd: Optional[BigDecimal] = None


class OrderActivityList(BaseModel):
    _type: _Type13 = Field(..., alias="@type")
    hash: Word
    maker: Address
    make: Asset
    take: Asset
    price: BigDecimal
    priceUsd: Optional[BigDecimal] = None


class OrderActivityCancelBid(BaseModel):
    _type: _Type14 = Field(..., alias="@type")
    hash: Word
    maker: Address
    make: AssetType
    take: AssetType
    transactionHash: Word
    blockHash: Word
    blockNumber: int
    logIndex: int


class OrderActivityCancelList(BaseModel):
    _type: _Type15 = Field(..., alias="@type")
    hash: Word
    maker: Address
    make: AssetType
    take: AssetType
    transactionHash: Word
    blockHash: Word
    blockNumber: int
    logIndex: int


class OrderEvent1(BaseModel):
    __root__: Union[OrderEvent, OrderUpdateEvent]


class NftItemEvent1(BaseModel):
    __root__: Union[NftItemEvent, NftItemUpdateEvent, NftItemDeleteEvent]


class NftOwnershipEvent1(BaseModel):
    __root__: Union[NftOwnershipEvent, NftOwnershipUpdateEvent, NftOwnershipDeleteEvent]


class OrderActivity(BaseModel):
    __root__: Union[
        OrderActivity1,
        OrderActivityMatch,
        OrderActivityBid,
        OrderActivityList,
        OrderActivityCancelBid,
        OrderActivityCancelList,
    ]


class OrderActivities(BaseModel):
    continuation: Optional[str] = Field(
        None, description="Continuation token to paginate items search result"
    )
    items: List[OrderActivity] = Field(..., description="List of found activities")


class Activity1(BaseModel):
    __root__: Union[Activity, OrderActivity, NftActivity]


class Activities(BaseModel):
    continuation: Optional[str] = None
    items: List[Activity1]
